var util = require('util');
var Service = require('../../service').Service;
var ServiceNode = require('../../node').ServiceNode;
var mage = require('../../../mage');
var crypto = require('crypto');
var requirePeer = require('codependency').get('mage');
var mdns = requirePeer('mdns');
var logger = mage.core.logger.context('mdns');

// Lookup map used to cache services' data. This is in the module global scope because if two
// submodules discover the same service we don't want to remember duplicates
var services = {};

/**
 * Hosts in mDNS are announced with a trailing dot, remove it
 *
 * @param {string} host
 * @returns {string}
 */
function normalizeHost(host) {
	if (!host) {
		return host;
	}

	if (host[host.length - 1] === '.') {
		host = host.substring(0, host.length - 1);
	}

	return host;
}

/**
 * Generates a name supposed to be unique on a mDNS network
 *
 * For more information on name registration, see:
 * https://developer.apple.com/library/mac/documentation/Networking/Conceptual/dns_discovery_api/Articles/registering.html
 *
 * @param {Service} service
 * @returns {string}
 */
function getUniqueName(service) {
	return service.name + service.type.name + service.type.protocol + service.replyDomain;
}

/**
 * This is our service object, it starts a browser object so that if can forward up and down events
 * when nodes appear on the network.
 *
 * @param {string} name                  The name of the service
 * @param {string} type                  The protocol used (eg: tcp)
 * @param {Object} options               Options
 * @param {string} options.description   Used to override the service name generated by the engine.
 *                                       It needs to be unique on the network!
 * @constructor
 */
function MDNSService(name, type, options) {
	var that = this;

	this.name = name;
	this.type = type;
	this.options = options;

	this.advertisement = null;
	this.browser = new mdns.Browser(mdns.makeServiceType(this.name, this.type));

	this.browser.on('serviceUp', function (service) {
		// we know that node, don't re-announce it
		if (services[getUniqueName(service)]) {
			return;
		}

		// this is our representation of a node, it contains the host, ips, port and metadata of a service
		var node = new ServiceNode(normalizeHost(service.host), service.port, service.addresses, service.txtRecord);
		services[getUniqueName(service)] = node;

		that.emit('up', node);
	});

	this.browser.on('serviceDown', function (service) {
		// retrieve the service object
		var node = services[getUniqueName(service)];

		// we never saw that node go up, don't emit a down
		if (!node) {
			return;
		}

		that.emit('down', node);

		// remove the data we knew about it
		delete services[getUniqueName(service)];
	});

	this.browser.on('error', function (error, service) {
		that.emit('error', error, service);
	});
}

util.inherits(MDNSService, Service);

/**
 * Announce our service on the mDNS network
 *
 * @param {number}   port
 * @param {Object}   metadata
 * @param {Function} cb
 */
MDNSService.prototype.announce = function (port, metadata, cb) {
	if (this.advertisement) {
		// stop current advertisement
		this.advertisement.stop();
	}

	var nodeEnv = process.env.NODE_ENV;
	if (!nodeEnv) {
		return cb(new Error(
			'No value was set for the environment variable "NODE_ENV". ' +
			'This variable is needed for mDNS announcements.'
		));
	}

	var serviceType = mdns.makeServiceType(this.name, this.type);

	// create our service announcement options
	var serviceOptions = {
		// set the description to be the PID followed by the game name
		name: nodeEnv + '/' + mage.rootPackage.name + ' (' + crypto.randomBytes(4).toString('hex') + ')',
		// this is our metadata
		txtRecord: metadata
	};

	if (Buffer.byteLength(serviceOptions.name) > 63) {
		// sha1 the damn thing so that it fits in 63 characters
		var oldName = serviceOptions.name;
		serviceOptions.name = crypto.createHash('sha1').update(oldName).digest('hex');

		// tell the user about it
		logger.warning('Generated service name is longer than 63 characters, it was hashed to "' +
			serviceOptions.name + '". Original name was "' + oldName + '"');
	}

	// override service description if defined in the options
	if (this.options && this.options.description) {
		serviceOptions.name = this.options.description;
	}

	// Advertise me! Callback is here to suppress the 2d argument provided by createAdvertisement
	this.advertisement = mdns.createAdvertisement(serviceType, port, serviceOptions, function (error) {
		if (cb) {
			cb(error);
		}
	});

	// start announcing
	this.advertisement.start();
};


/**
 * Starts service discovery on the browser
 */

MDNSService.prototype.discover = function () {
	this.browser.start();
};


MDNSService.prototype.close = function (cb) {
	if (this.advertisement) {
		this.advertisement.stop();
		this.advertisement = null;
	}

	this.browser.stop();

	setImmediate(cb);
};


/**
 * Creates a version of the service using the type and options provided
 *
 * @param {string} name    The service name, used for filtering
 * @param {string} type    The service type, either tcp or udp or whatev
 * @param {Object} options Configuration to provide to the service
 * @returns {MDNSService}
 */
exports.create = function (name, type, options) {
	return new MDNSService(name, type, options);
};
